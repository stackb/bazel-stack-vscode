import * as vscode from 'vscode';
import { ICommandCodeLensProviderRegistry } from '../api';
import { CommandName } from './constants';

/**
 * runContext captures information needed to run a bazel command.
 */
export type RunContext = {
  cwd: string;
  command: string;
  args: string[];
  executable?: string;
  matcher?: string;
};

/**
 * Codelens provider that scans for command names in .
 */
export class BazelrcCodelens implements vscode.Disposable, vscode.CodeLensProvider {
  /** Fired when selected files change in the workspace. */
  private onDidChangeCodeLensesEmitter = new vscode.EventEmitter<void>();
  public onDidChangeCodeLenses = this.onDidChangeCodeLensesEmitter.event;

  private disposables: vscode.Disposable[] = [];
  // represents the last run; we can replay it with a separate command
  private lastRun: RunContext | undefined;

  constructor(
    private bazelExecutable: string,
    private commandCodeLensProviderRegistry: ICommandCodeLensProviderRegistry
  ) {
    this.disposables.push(
      commandCodeLensProviderRegistry.onDidChangeCommandCodeLenses(name => {
        this.onDidChangeCodeLensesEmitter.fire();
      })
    );
  }

  public async setup(skipInstallCommands?: boolean) {
    const bazelrcWatcher = vscode.workspace.createFileSystemWatcher(
      '**/launch*.bazelrc',
      true, // ignoreCreateEvents
      false,
      true // ignoreDeleteEvents
    );

    bazelrcWatcher.onDidChange(
      uri => {
        this.onDidChangeCodeLensesEmitter.fire();
      },
      this,
      this.disposables
    );

    this.disposables.push(bazelrcWatcher);

    // HACK: For unknown reason, the application under test performs duplicate
    // registration of these commands.
    if (!skipInstallCommands) {
      this.disposables.push(
        vscode.commands.registerCommand(CommandName.RunCommand, this.runCommand, this)
      );
      this.disposables.push(
        vscode.commands.registerCommand(CommandName.RerunCommand, this.rerunCommand, this)
      );

      this.disposables.push(
        vscode.languages.registerCodeLensProvider([{ pattern: '**/launch*.bazelrc' }], this)
      );
    }
  }

  /**
   * Runs a bazel command and streams output to the terminal.
   *
   * @param runCtx The run context.
   */
  async rerunCommand() {
    if (this.lastRun === undefined) {
      return;
    }
    vscode.tasks.executeTask(createRunCommandTask(this.lastRun));
  }

  /**
   * Runs a bazel command and streams output to the terminal.
   *
   * @param runCtx The run context.
   */
  async runCommand(runCtx: RunContext | undefined) {
    if (runCtx === undefined) {
      return;
    }
    if (!runCtx.executable) {
      runCtx.executable = this.bazelExecutable;
    }
    this.lastRun = runCtx;
    vscode.tasks.executeTask(createRunCommandTask(runCtx));
  }

  /**
   * Provides promisified CodeLen(s) for the given document.
   *
   * @param document A bazelrc file
   * @param token CodeLens token automatically generated by VS Code when
   *     invoking the provider
   */
  public async provideCodeLenses(
    document: vscode.TextDocument,
    token: vscode.CancellationToken
  ): Promise<vscode.CodeLens[] | undefined> {
    if (document.isDirty) {
      // Don't show code lenses for dirty files
      return;
    }
    return this.computeCodeLenses(document, token, document.getText());
  }

  /**
   * Computes lenses for the given document.
   *
   * @param text
   */
  private async computeCodeLenses(
    document: vscode.TextDocument,
    token: vscode.CancellationToken,
    text: string
  ): Promise<vscode.CodeLens[] | undefined> {
    const lines = text.split(/\r?\n/);
    let lenses: vscode.CodeLens[] = [];

    for (let i = lines.length - 1; i >= 0; i--) {
      const line = lines[i].trim();
      // skip comments
      if (line.startsWith('#')) {
        continue;
      }

      // join to prev line if this is a continuation
      if (i > 0) {
        const prevLine = lines[i - 1].trim();
        if (!prevLine.startsWith('#') && prevLine.endsWith('\\')) {
          lines[i - 1] = prevLine.slice(0, -1) + line;
          continue;
        }
      }

      // check the token for a recognized command
      const tokens = line.split(/\s+/g);
      if (tokens.length < 2) {
        continue;
      }

      let command = tokens[0];

      const provider = this.commandCodeLensProviderRegistry.getCommandCodeLensProvider(command);
      if (!provider) {
        continue;
      }

      const list = await provider.provideCommandCodeLenses(
        document,
        token,
        i,
        0,
        command,
        tokens.slice(1)
      );
      if (list) {
        lenses = lenses.concat(list);
      }
    }

    return lenses.length ? lenses : undefined;
  }

  public dispose() {
    for (const disposable of this.disposables) {
      disposable.dispose();
    }
  }
}

/**
 * Creates a new task that invokes a command.
 *
 * @param command The Bazel command to execute.
 * @param options Describes the options used to launch Bazel.
 */
export function createRunCommandTask(runCtx: RunContext): vscode.Task {
  const taskDefinition = {
    type: 'bazelrc',
  };
  const scope = vscode.TaskScope.Workspace;
  const name = runCtx.command;
  const source = 'bazel';
  const execution = new vscode.ShellExecution(
    [runCtx.executable, runCtx.command].concat(runCtx.args).join(' '),
    {
      cwd: runCtx.cwd,
    }
  );
  let problemMatchers: string[] | undefined;
  if (runCtx.matcher) {
    problemMatchers = [runCtx.matcher];
  }
  return new vscode.Task(taskDefinition, scope, name, source, execution, problemMatchers);
}
